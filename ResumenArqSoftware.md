üèõÔ∏è EL COMPENDIO MAESTRO DE ARQUITECTURA DE SOFTWAREEdici√≥n Completa: Sistemas, Datos, Resiliencia y C√≥digo.I. Nivel Macro: Arquitecturas de SistemaDefine la estructura global, el despliegue y la topolog√≠a f√≠sica.1. Monolito (The Monolith)Todo el c√≥digo (Frontend, Backend, DB Access) vive en una √∫nica unidad desplegable.Variantes: Cl√°sico (una gran bola de c√≥digo) o Modular (separado internamente por carpetas).Pros: Despliegue simple, latencia cero entre m√≥dulos, ideal para equipos peque√±os.Contras: Escalado ineficiente (todo o nada), acoplamiento alto, un error tumba todo.Uso: MVPs, Startups fase temprana, aplicaciones con dominio simple.2. MicroserviciosDescomposici√≥n en servicios peque√±os y aut√≥nomos (ej: ServicioPagos, ServicioUsuarios) que se comunican por red.Pros: Escalabilidad granular, libertad tecnol√≥gica por servicio, despliegue independiente.Contras: Complejidad operativa extrema (DevOps), latencia de red, consistencia de datos dif√≠cil.Uso: Netflix, Uber, Sistemas Enterprise masivos.3. Serverless (FaaS - Function as a Service)La infraestructura es invisible. El c√≥digo son funciones ef√≠meras activadas por eventos.Pros: Costo por uso real, escalado infinito autom√°tico, NoOps.Contras: "Cold Starts" (arranque lento), p√©rdida de estado en memoria (stateless), Vendor Lock-in.Uso: Procesamiento de eventos, APIs con tr√°fico variable, "Glue code".4. Arquitectura Orientada a Eventos (EDA)Los componentes no se llaman ("Haz esto"), sino que emiten sucesos ("Esto pas√≥").Modelos: Pub/Sub (Kafka, RabbitMQ) o Event Streaming.Pros: Desacoplamiento total, alta reactividad.Contras: Dificultad para rastrear el flujo (no lineal), consistencia eventual.Uso: IoT, Sistemas financieros as√≠ncronos, E-commerce.II. Nivel Estructura: Organizaci√≥n del C√≥digoC√≥mo ordenamos las carpetas y dependencias dentro de un servicio.1. Arquitectura de N-Capas (Layered)Divisi√≥n horizontal t√©cnica: Presentaci√≥n -> Negocio -> Datos.Pros: Est√°ndar cl√°sico, f√°cil de entender.Contras: Dificulta cambios verticales (una feature toca 3 capas), riesgo de "Modelos An√©micos".2. Arquitectura Hexagonal (Ports & Adapters) / CleanEl Dominio (L√≥gica) est√° al centro, aislado de Frameworks, UI y BD mediante Interfaces (Puertos).Pros: Testabilidad total, independencia de tecnolog√≠a externa.Contras: Verboso (muchos mappers e interfaces).Uso: Core bancario, l√≥gica de negocio compleja y longeva.3. Vertical Slice Architecture (Cortes Verticales) üÜïOrganizaci√≥n por Features (Funcionalidades), no por capas t√©cnicas. Una carpeta CreateTransaction contiene todo lo necesario: UI, API Handler, L√≥gica y Query SQL.Pros: Alta cohesi√≥n (todo lo relacionado cambia junto), bajo acoplamiento, ideal para DDD.Contras: Posible duplicaci√≥n de c√≥digo si no se extraen compartidos (shared).Uso: Modern Web Apps (Next.js), Sistemas √°giles.III. Nivel Datos: Integridad y Consistencia (Misi√≥n Cr√≠tica)C√≥mo garantizar que los datos (especialmente dinero) nunca se pierdan ni corrompan.1. ACID (Transacciones Estrictas)Atomicidad, Consistencia, Aislamiento, Durabilidad.Regla: "Todo o nada". Si una transferencia falla a la mitad, se deshace todo.Uso: Finanzas, Inventarios, Datos relacionales.2. Idempotencia (Idempotency Patterns) üÜïGarant√≠a de que procesar una misma petici√≥n m√∫ltiples veces tiene el mismo efecto que una sola vez.Mecanismo: El cliente env√≠a una Idempotency-Key. El servidor verifica si ya proces√≥ esa clave antes de ejecutar.Uso: Evitar cobros dobles cuando el usuario hace "doble clic" o hay reintentos de red.3. Transactional Outbox Pattern üÜïGarantiza la atomicidad entre "Guardar en BD" y "Enviar un Mensaje/Email".Flujo: Guardar el dato y el evento en la misma transacci√≥n de BD (tabla Outbox). Un worker lee la tabla y env√≠a el mensaje.Uso: Notificaciones de pago, Sincronizaci√≥n entre microservicios.4. Audit Log Inmutable (Ledger) üÜïRegistro de seguridad "Solo Escritura" (Append-Only).Concepto: No basta con logs de consola. Se guarda en BD: Qui√©n, Qu√©, Cu√°ndo, Dato Anterior, Dato Nuevo.Uso: Compliance legal, Seguridad forense, Sistemas bancarios.IV. Nivel Resiliencia: Tolerancia a FallosC√≥mo evitar que el sistema colapse bajo estr√©s.1. Circuit Breaker Distribuido (Redis-Backed) üÜïUn interruptor que corta el acceso a un servicio fallido para dejarlo recuperarse.Especial para Serverless: Como la memoria se borra en Serverless, el estado del circuito (Abierto/Cerrado) se guarda en Redis para compartirlo entre todas las instancias.Uso: Protecci√≥n de APIs externas y Bases de Datos en entornos Lambda/Vercel.2. API Gateway / BFFPunto de entrada √∫nico que gestiona autenticaci√≥n, ruteo y adaptaci√≥n de respuestas para diferentes clientes (Web vs M√≥vil).3. Rate LimitingLimitar el n√∫mero de peticiones por usuario/IP para evitar ataques DDoS o saturaci√≥n.V. Nivel C√≥digo: Flujo y Errores (Functional Patterns)C√≥mo escribir l√≥gica robusta y predecible.1. Result Pattern / Railway Oriented Programming (ROP) üÜïEn lugar de try/catch, las funciones devuelven objetos expl√≠citos: Ok<T> o Err<E>.Pros: Obliga a manejar el error, seguro para serializaci√≥n (Server Actions/RSC), flujo de "v√≠as de tren" (Green path / Red path).Uso: Validaciones, L√≥gica de negocio cr√≠tica, Server Actions.2. Pipeline PatternEncadenar operaciones donde la salida de una es la entrada de la siguiente.Uso: Procesamiento de datos, Middlewares.VI. Nivel UI: Arquitectura FrontendC√≥mo organizar la interfaz de usuario de forma mantenible.1. Semantic Composition & CSS Modules üÜïRechazo a las "Utility Classes" masivas (Tailwind) en favor de CSS sem√°ntico y modular.T√©cnica: Uso de composes para reutilizar estilos y componentes de layout (Flex, Grid, Card) que encapsulan la estructura.Uso: Sistemas de dise√±o estrictos, mantenibilidad a largo plazo, separaci√≥n HTML/Estilo.2. Mediator Pattern (UI) üÜïPara componentes complejos (ej: Modales, Wizards). Un "Mediador" gestiona la l√≥gica de comunicaci√≥n entre las partes (Bot√≥n, Contenido, Overlay) para que no se acoplen entre s√≠.3. Component-Based ArchitectureUI dividida en piezas reutilizables (React, Vue). Estado fluye hacia abajo (props), eventos hacia arriba.VII. Nivel Micro: Patrones de Dise√±o (GoF - Resumen)Soluciones a nivel de clases y objetos.Categor√≠aPatr√≥nDescripci√≥n BreveCreacionalesSingletonUna sola instancia (Cuidado: estado global).FactoryCrea objetos sin exponer la l√≥gica de creaci√≥n.BuilderConstruye objetos complejos paso a paso.EstructuralesAdapterConecta interfaces incompatibles.FacadeSimplifica un sistema complejo tras una fachada.DecoratorA√±ade funcionalidad din√°micamente ("wrappers").ComportamientoObserverSuscripci√≥n a eventos/cambios de estado.StrategyIntercambia algoritmos en tiempo de ejecuci√≥n.CommandEncapsula una petici√≥n como un objeto.